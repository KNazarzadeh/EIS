classdef FVMelectrolyte
    % FVM class for computing Single Particle Model (SPM) and Multi-Particle Model (MPM) matrices
    % using Finite Volume Method for lithium-ion battery diffusion
    % Reference: http://dx.doi.org/10.1109/CDC.2015.7402829

    methods(Static)
        %% ------------------------ Electrolyte Length Size ------------------------------- %%
        function [numSpatialNodes, spatialGridSpacing, surface_specific_interfacial_surface_area, ...
                electrolyte_volume_fraction] = compute_initialVectors(GeometricParams, electrode)

            % Prefix for electrodes ('neg', 'pos')
            prefix = electrode{1}(1:3);
            Geom = GeometricParams.electrode.(electrode);

            numSpatialNodes = Geom.(['number_spatial_nodes_' prefix]);
            spatialGridSpacing = Geom.(['spatialGridSpacing_' prefix]);


            surface_specific_interfacial_surface_area = Geom.particles.(['specific_interfacial_surface_area_' prefix]);

            electrolyte_volume_fraction = Geom.(['electrolyte_volume_fraction_' prefix]);

        end

        %% ------------------------ Electrolyte Length Size Full Cell ------------------------------- %%
        function [numSpatialNodes_neg, spatialGridSpacing_neg, ...
                surface_specific_interfacial_surface_area_neg, ...
                electrolyte_volume_fraction_neg, ...
                numSpatialNodes_pos, spatialGridSpacing_pos, ...
                surface_specific_interfacial_surface_area_pos, electrolyte_volume_fraction_pos, ...
                numSpatialNodes_sep, ...
                transference_ion_number_elyte, numSpatialNodes_total, ...
                spatialGridSpacing_scale_total, electrolyte_fraction_scale_total] = ...
                    compute_initialVectors_FullCell(GeometricParams, TransportParams)

            [numSpatialNodes_neg, spatialGridSpacing_neg, surface_specific_interfacial_surface_area_neg, electrolyte_volume_fraction_neg] = ...
                FVMelectrolyte.compute_initialVectors(GeometricParams, "negative");

            [numSpatialNodes_pos, spatialGridSpacing_pos,surface_specific_interfacial_surface_area_pos, electrolyte_volume_fraction_pos] = ...
                FVMelectrolyte.compute_initialVectors(GeometricParams, "positive");

            numSpatialNodes_sep = GeometricParams.separator.('number_spatial_nodes_sep');
            electrolyte_volume_fraction_sep = GeometricParams.separator.('electrolyte_volume_fraction_sep');
            spatialGridSpacing_sep = GeometricParams.separator.('spatialGridSpacing_sep');

            transference_ion_number_elyte = TransportParams.electrolyte.('transference_ion_number_elyte');

            numSpatialNodes_total = numSpatialNodes_neg + numSpatialNodes_pos + numSpatialNodes_sep;

            spatialGridSpacing_scale_neg = spatialGridSpacing_neg * ones(numSpatialNodes_neg, 1);
            spatialGridSpacing_scale_pos = spatialGridSpacing_pos * ones(numSpatialNodes_pos, 1);

            spatialGridSpacing_scale_sep = spatialGridSpacing_sep * ones(numSpatialNodes_sep, 1);

            spatialGridSpacing_scale_total = [spatialGridSpacing_scale_neg; 
                                              spatialGridSpacing_scale_sep; 
                                              spatialGridSpacing_scale_pos
                                             ];

            electrolyte_fraction_scale_total = [...
                electrolyte_volume_fraction_neg * ones(numSpatialNodes_neg, 1);
                electrolyte_volume_fraction_sep * ones(numSpatialNodes_sep, 1);
                electrolyte_volume_fraction_pos * ones(numSpatialNodes_pos, 1)
                ];
        end

        %% ------------------------ Total Boundary Flux Matrix Full Cell ---------------------- %%
        function boundaryFluxElyte = compute_boundaryFluxElyte_FullCell( ...
            numSpatialNodes_neg, electrolyte_volume_fraction_neg, surface_specific_interfacial_surface_area_neg, ...
            numSpatialNodes_pos, electrolyte_volume_fraction_pos, surface_specific_interfacial_surface_area_pos, ...
            transference_ion_number_elyte, ...
            numSpatialNodes_sep)
            
            % Computes the full boundary flux matrix for negative regions
            boundaryFluxElectrolyte_scalar_neg = surface_specific_interfacial_surface_area_neg * ...
                            (1 - transference_ion_number_elyte) / electrolyte_volume_fraction_neg;

            % Replicate for all negative nodes
            boundaryFlux_neg = boundaryFluxElectrolyte_scalar_neg * ones(numSpatialNodes_neg, 1);  % size [numSpatialNodes x 1] 

            % Computes the full boundary flux matrix for positive regions
            boundaryFluxElectrolyte_scalar_pos = surface_specific_interfacial_surface_area_pos * ...
                            (1 - transference_ion_number_elyte) / electrolyte_volume_fraction_pos;

            % Replicate for all positive nodes
            boundaryFlux_pos = boundaryFluxElectrolyte_scalar_pos * ones(numSpatialNodes_pos, 1);  % size [numSpatialNodes x 1] 

          
            boundaryFlux = (blkdiag(boundaryFlux_neg, boundaryFlux_pos));

            boundaryFlux_sep = zeros(numSpatialNodes_sep, 2);  % Separator has no source terms

            % Combine into block-diagonal matrix
            boundaryFluxElyte = sparse([ ...
                                        boundaryFlux(1:numSpatialNodes_neg, :); ...
                                        boundaryFlux_sep; ...
                                        boundaryFlux(numSpatialNodes_neg+1:end, :) ...
                                        ]);                
        end

        %% ------------------------ Discrete-Time Total Boundary Flux Matrix full Cell ---------------------- %%        
        function boundaryFluxElectrolyteDiscreteTime = compute_boundaryFluxElectrolyteDiscreteTime_FullCell( ...
                numSpatialNodes_neg, electrolyte_volume_fraction_neg, surface_specific_interfacial_surface_area_neg, ...
                numSpatialNodes_pos, electrolyte_volume_fraction_pos, surface_specific_interfacial_surface_area_pos, ...
                transference_ion_number_elyte, numSpatialNodes_sep, timeStep)

            % Computes discrete-time boundary flux matrix B_cs_hat
            boundaryFluxElyte = FVMelectrolyte.compute_boundaryFluxElyte_FullCell( ...
                numSpatialNodes_neg, electrolyte_volume_fraction_neg, surface_specific_interfacial_surface_area_neg, ...
                numSpatialNodes_pos, electrolyte_volume_fraction_pos, surface_specific_interfacial_surface_area_pos, ...
                transference_ion_number_elyte, ...
                numSpatialNodes_sep);

            boundaryFluxElectrolyteDiscreteTime = boundaryFluxElyte * timeStep;
        end
      
        
        %% ------------------------ Surface matrix Full Cell ---------------------- %%
        function surfaceDiffusionMatrix = compute_surfaceDiffusionMatrix_FullCell( ...
                ThermalParams, ...
                TransportParams, ...
                concentration_elyte, ...
                spatialGridSpacing_scale_total, ...
                electrolyte_fraction_scale_total, ...
                temperature ...
                )

            % Computes output matrix Acs for surface concentrations
            fvm_method = 'harmonic';
            
            porosityScaling = electrolyte_fraction_scale_total .* spatialGridSpacing_scale_total;

            calculator = TransportParametersCalculator();
            effective_diffusion_elyte = calculator.compute_effective_diffusion_electrolyte( ...
                ThermalParams, ...
                TransportParams, ...
                concentration_elyte, ...
                temperature);

            surfaceDiffusionMatrix = sparse(buildInterfaceMatrix(effective_diffusion_elyte, ...
                                              porosityScaling, ...
                                              spatialGridSpacing_scale_total, ...
                                              fvm_method));
        end
        
        %% ------------------------ Discrete-Time Matrix Full Cell ---------------------- %%
        function surfaceDiffusionElyteDiscreteTime = compute_surfaceDiffusionElyteDiscreteTime_FullCell( ...
                ThermalParams, ...
                TransportParams, ...
                concentration_elyte, ...
                numSpatialNodes_total, ...
                spatialGridSpacing_scale_total, ...
                electrolyte_fraction_scale_total, ...
                temperature, ...
                timeStep)

            surfaceDiffusionMatrix = FVMelectrolyte.compute_surfaceDiffusionMatrix_FullCell( ...
                ThermalParams, ...
                TransportParams, ...
                concentration_elyte, ...
                spatialGridSpacing_scale_total, ...
                electrolyte_fraction_scale_total, ...
                temperature);

            surfaceDiffusionElyteDiscreteTime = timeStep * surfaceDiffusionMatrix - speye(numSpatialNodes_total);
        end
        %% ------------------------ Surface matrix Full Cell ---------------------- %%
        function surfaceDiffusionMatrix = compute_surfaceDiffusionMatrix_diff_func_FullCell( ...
                ThermalParams, ...
                TransportParams, ...
                concentratios_elyte, ...
                spatialGridSpacing_scale_total, ...
                electrolyte_fraction_scale_total, ...
                temperature)

            % Computes output matrix Acs for surface concentrations
            
            fvm_method = 'harmonic';
    
            porosityScaling = electrolyte_fraction_scale_total .* spatialGridSpacing_scale_total;

            calculater = TransportParametersCalculator();
            effective_diffusion_elyte = calculater.compute_effective_diffusion_electrolyte( ...
                ThermalParams, ...
                TransportParams, ...
                concentratios_elyte, ...
                temperature);

            surfaceDiffusionMatrix = sparse(buildInterfaceMatrix(effective_diffusion_elyte, ...
                                                  porosityScaling, ...
                                                  spatialGridSpacing_scale_total, ...
                                                  fvm_method));
        end
        %% ------------------------ Discrete-Time Matrix Full Cell ---------------------- %%
        function surfaceDiffusionElyteDiscreteTime = compute_surfaceDiffusionElyteDiscreteTime_diff_func_FullCell( ...
                ThermalParams, ...
                TransportParams, ...
                concentratios_elyte, ...
                numSpatialNodes_total, ...
                spatialGridSpacing_scale_total, ...
                electrolyte_fraction_scale_total, ...
                temperature, ...
                timeStep)

            surfaceDiffusionMatrix = FVMelectrolyte.compute_surfaceDiffusionMatrix_diff_func_FullCell( ...
                ThermalParams, ...
                TransportParams, ...
                concentratios_elyte, ...
                spatialGridSpacing_scale_total, ...
                electrolyte_fraction_scale_total, ...
                temperature);

            surfaceDiffusionElyteDiscreteTime = timeStep * surfaceDiffusionMatrix - speye(numSpatialNodes_total);
        end

        %% ------------------------ Surface Concentrations matrix Full Cell ---------------------- %%
        function surfaceConcenElyte = compute_surfaceConcenElyte_FullCell(numSpatialNodes_neg, ...
                numSpatialNodes_pos, numSpatialNodes_sep)     % Acs_bar

            % Computes output matrix Acs_bar for surface concentrations
            numSpatialNodes_neg_sep = numSpatialNodes_neg + numSpatialNodes_sep;

            Ace_tmp = blkdiag(eye(numSpatialNodes_neg), zeros(numSpatialNodes_sep), eye(numSpatialNodes_pos)); 

            surfaceConcenElyte = sparse([Ace_tmp(1:numSpatialNodes_neg, :); Ace_tmp(numSpatialNodes_neg_sep+1:end, :)]); 
        end

        %% ------------------------ Electrolyte Boundary Potential Full Cell ---------------------- %%
        function boundaryPotentialElyte = compute_boundaryPotentialElyte_FullCell( ...
                numSpatialNodes_neg, ...
                numSpatialNodes_pos, ...
                numSpatialNodes_sep,...
                surface_specific_interfacial_surface_area_neg, ...
                surface_specific_interfacial_surface_area_pos, ...
                spatialGridSpacing_neg, ...
                spatialGridSpacing_pos)

            constants = ConstantParameters();

            boundaryPotential_neg = surface_specific_interfacial_surface_area_neg * constants.F .* spatialGridSpacing_neg; 
            boundaryPotential_pos = surface_specific_interfacial_surface_area_pos * constants.F .* spatialGridSpacing_pos; 

            boundaryPotential = (blkdiag(boundaryPotential_neg * ones(numSpatialNodes_neg, 1), ...
                                        boundaryPotential_pos * ones(numSpatialNodes_pos, 1)));

            boundaryPotential_sep = zeros(numSpatialNodes_sep, 2);  % Separator has no source terms
            
            % Combine into block-diagonal matrix
            boundaryPotentialElyte = sparse([boundaryPotential(1:numSpatialNodes_neg, :); ...
                                            boundaryPotential_sep; ...
                                            boundaryPotential(numSpatialNodes_neg+1:end, :) ...
                                            ]);
    
            % Combine into block-diagonal matrix
            boundaryPotentialElyte(end) = 0; 
        end

        %% ------------------------ Discrete-Time Total Boundary Flux Matrix Full Cell ---------------------- %%        
        function boundaryPotentialElyteDiscreteTime = compute_boundaryPotentialElyteDiscreteTime_FullCell( ...
                numSpatialNodes_neg, ...
                numSpatialNodes_pos, ...
                numSpatialNodes_sep,...
                surface_specific_interfacial_surface_area_neg, ...
                surface_specific_interfacial_surface_area_pos, ...
                spatialGridSpacing_neg, ...
                spatialGridSpacing_pos, ...
                timeStep)

            boundaryPotentialElyte = FVMelectrolyte.compute_boundaryPotentialElyte_FullCell( ...
                numSpatialNodes_neg, ...
                numSpatialNodes_pos, ...
                numSpatialNodes_sep,...
                surface_specific_interfacial_surface_area_neg, ...
                surface_specific_interfacial_surface_area_pos, ...
                spatialGridSpacing_neg, ...
                spatialGridSpacing_pos);

            boundaryPotentialElyteDiscreteTime = boundaryPotentialElyte * timeStep;

        end

        %% ------------------------ Electrolyte Potential cell matrix Full Cell ---------------------- %%
        function surfacePotentialMatrix = compute_surfacePotentialMatrix_FullCell( ...
            ThermalParams, ... 
            TransportParams, ...
            concentration_elyte, ...
            numSpatialNodes_total, ...
            spatialGridSpacing_scale_total, ...
            temperature ...
            )

            % Computes output matrix Acs for surface concentrations
            
            fvm_method = 'harmonic';
        
            calTrnasport = TransportParametersCalculator();
            effective_conductivity_elyte = ...
                calTrnasport.compute_effective_conductivity_electrolyte( ...
                ThermalParams, ... 
                TransportParams, ...
                concentration_elyte, ...
                temperature);


            surfacePotentialMatrix = sparse(buildInterfaceMatrix(effective_conductivity_elyte, ...
                                                          ones(numSpatialNodes_total,1), ...
                                                          spatialGridSpacing_scale_total, ...
                                                          fvm_method));

            surfacePotentialMatrix(end,end-1:end) = [0 1];
        end
        %% ------------------------ Discrete-Time Matrix ---------------------- %%
        function surfacePotentialElyteDiscreteTime = compute_surfacePotentialElyteDiscreteTime_FullCell( ...
                ThermalParams, ... 
                TransportParams, ...
                concentration_elyte, ...
                numSpatialNodes_total, ...
                spatialGridSpacing_scale_total, ...                
                temperature, ...
                timeStep)  

            ElectrolytepotentialMatrix = FVMelectrolyte.compute_surfacePotentialMatrix_FullCell( ...
                ThermalParams, ... 
                TransportParams, ...
                concentration_elyte, ...
                numSpatialNodes_total, ...
                spatialGridSpacing_scale_total, ...
                temperature);

            surfacePotentialElyteDiscreteTime = ElectrolytepotentialMatrix * timeStep;
        end

        %% ------------------------ Electrolyte Diffusion Potential Matrix ---------------------- %%
        function diffusionPotentialElyteMatrix = compute_diffusionPotentialElyteMatrix_FullCell( ...
                ThermalParams, ... 
                TransportParams, ...
                concentration_elyte, ...
                numSpatialNodes_total, ...
                spatialGridSpacing_scale_total, ...
                temperature ...
                )

                fvm_method = 'harmonic';
                
                calTrnasport = TransportParametersCalculator();
                thermodynamic_factor = calTrnasport.compute_thermodynamic_factor( ...
                    ThermalParams, ... 
                    TransportParams, ...
                    concentration_elyte, ...
                    temperature);

                diffusionPotentialElyteMatrix = sparse(buildInterfaceMatrix(thermodynamic_factor, ...
                    ones(numSpatialNodes_total, 1), ...
                    spatialGridSpacing_scale_total, ...
                    fvm_method));

                diffusionPotentialElyteMatrix(end,end-1:end) = [0 0];
        end

        %% ------------------------ Electrolyte Diffusion Potential Matrix ---------------------- %%
        function conductivityPotentialElytematrix = compute_conductivityPotentialElytematrix_FullCell( ...
                domain, ...
                method, ...
                concentration_elyte, ...
                temperature ...
                )

                % Prefix for electrodes ('neg', 'pos', 'sep')
                prefix = char(extractBefore(domain,4));
    
                calTrnasport = TransportParametersCalculator();
                effective_conductivity_elyte = calTrnasport.compute_effective_conductivity_electrolyte( ...
                    concentration_elyte, ...
                    temperature);

                spatialGridSpacing = obj.battery.GeometricParams.electrode.(electrode).(['spatialGridSpacing_' prefix]);
                numSpatialNodes = obj.battery.GeometricParams.electrode.(electrode).(['number_spatial_nodes_' prefix]);
    
                conductivityPotentialElytematrix = sparse(buildInterfaceMatrix(effective_conductivity_elyte, ...
                    ones(numSpatialNodes,1), ...
                    spatialGridSpacing, ...
                    method));

        end
        %% ------------------------ Electrolyte FVM matirces Full Cell ---------------------- %%
        function preComputedMatrix = compute_electrolyteFVMMatirces_FullCell(GeometricParams, ...
                TransportParams, ...
                ThermalParams, ...
                concentration_elyte, ...
                temperature, ...
                timeStep)

                [numSpatialNodes_neg, spatialGridSpacing_neg, ...
                surface_specific_interfacial_surface_area_neg, electrolyte_volume_fraction_neg, ...
                numSpatialNodes_pos, spatialGridSpacing_pos, ...
                surface_specific_interfacial_surface_area_pos, electrolyte_volume_fraction_pos, ...
                numSpatialNodes_sep, ...
                transference_ion_number_elyte, numSpatialNodes_total, ...
                spatialGridSpacing_scale_total, electrolyte_fraction_scale_total] = FVMelectrolyte.compute_initialVectors_FullCell(GeometricParams, TransportParams);

            boundaryFluxElectrolyteDiscreteTime = FVMelectrolyte.compute_boundaryFluxElectrolyteDiscreteTime_FullCell( ...
                numSpatialNodes_neg, electrolyte_volume_fraction_neg, surface_specific_interfacial_surface_area_neg, ...
                    numSpatialNodes_pos, electrolyte_volume_fraction_pos, surface_specific_interfacial_surface_area_pos, ...
                    transference_ion_number_elyte, numSpatialNodes_sep, timeStep);

            boundaryPotentialElyteDiscreteTime = FVMelectrolyte.compute_boundaryPotentialElyteDiscreteTime_FullCell( ...
                numSpatialNodes_neg, ...
                numSpatialNodes_pos, ...
                numSpatialNodes_sep,...
                surface_specific_interfacial_surface_area_neg, ...
                surface_specific_interfacial_surface_area_pos, ...
                spatialGridSpacing_neg, ...
                spatialGridSpacing_pos, ...
                timeStep);

            surfaceDiffusionElyteDiscreteTime = FVMelectrolyte.compute_surfaceDiffusionElyteDiscreteTime_FullCell( ...
                ThermalParams, ...
                TransportParams, ...
                concentration_elyte, ...
                numSpatialNodes_total, ...
                spatialGridSpacing_scale_total, ...
                electrolyte_fraction_scale_total, ...
                temperature, ...
                timeStep);

            surfacePotentialElyteMatrix = FVMelectrolyte.compute_surfacePotentialMatrix_FullCell( ...
                ThermalParams, ... 
                TransportParams, ...
                concentration_elyte, ...
                numSpatialNodes_total, ...
                spatialGridSpacing_scale_total, ...
                temperature);

            diffusionPotentialElyteMatrix = FVMelectrolyte.compute_diffusionPotentialElyteMatrix_FullCell( ...
                ThermalParams, ... 
                TransportParams, ...
                concentration_elyte, ...
                numSpatialNodes_total, ...
                spatialGridSpacing_scale_total, ...
                temperature);
                
            preComputedMatrix.boundaryFluxElectrolyteDiscreteTime = boundaryFluxElectrolyteDiscreteTime;
            preComputedMatrix.boundaryPotentialElyteDiscreteTime = boundaryPotentialElyteDiscreteTime;
            preComputedMatrix.surfaceDiffusionElyteDiscreteTime = surfaceDiffusionElyteDiscreteTime;
            preComputedMatrix.surfacePotentialElyteMatrix = surfacePotentialElyteMatrix;
            preComputedMatrix.diffusionPotentialElyteMatrix = diffusionPotentialElyteMatrix;
        end
    end
end

